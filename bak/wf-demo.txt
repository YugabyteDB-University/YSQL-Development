./bin/yb-ctl --rf 3 create --tserver_flags "yb_num_shards_per_tserver=1,ysql_num_shards_per_tserver=1" --master_flags  "yb_num_shards_per_tserver=1,ysql_num_shards_per_tserver=1" --num_shards_per_tserver=1 --placement_info "azure.region1.zone1,azure.region1.zone2,azure.region1.zone3"



create database ybu_demo;
\c ybu_demo;

Step 1. Create Table
Create two tables: dept and emp
Description
Create two tables(dept and emp) by using the following CREATE TABLE commands.



SQL Statement
Step 1: Create a table called dept
Copy
Run
DROP TABLE public.dept;
CREATE TABLE IF NOT EXISTS public.dept (
  deptno integer NOT NULL,
  dname text,
  loc text,
  description text,
  CONSTRAINT pk_dept PRIMARY KEY (deptno asc)
);
     

Step 2: Create another table called emp
Copy
Run
DROP TABLE emp;
CREATE TABLE IF NOT EXISTS emp (
  empno integer generated by default as identity (start with 10000) NOT NULL,
  ename text NOT NULL,
  job text,
  mgr integer,
  hiredate date,
  sal integer,
  comm integer,
  deptno integer NOT NULL,
  email text,
  other_info jsonb,
  CONSTRAINT pk_emp PRIMARY KEY (empno hash),
  CONSTRAINT emp_email_uk UNIQUE (email),
  CONSTRAINT emp_email_check CHECK ((email ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'::text))
);



Step 2. Insert Data
Insert data into dept and emp tables

Minimize
Close
Description
Insert data into dept and emp tables.

SQL Statement
Step 1: Insert data into dept table
Copy
Run
INSERT INTO dept (deptno, dname, loc, description)
VALUES 
(10, 'ACCOUNTING', 'NEW YORK','preparation of financial statements, maintenance of general ledger, payment of bills, preparation of customer bills, payroll, and more.'),
(20, 'RESEARCH', 'DALLAS','responsible for preparing the substance of a research report or security recommendation.'),
 (30, 'SALES', 'CHICAGO','division of a business that is responsible for selling products or services'),
(40, 'OPERATIONS', 'BOSTON','administration of business practices to create the highest level of efficiency possible within an organization');
    

Step 2: Insert data into emp table.
Copy
Run


INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7369, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, NULL, 20,'SMITH@acme.com', '{"skills":["accounting"]}');
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300, 30,'ALLEN@acme.com', null);
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30,'WARD@compuserve.com', null);
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, NULL, 20,'JONES@gmail.com', null);
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30,'MARTIN@acme.com', null);
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, NULL, 30,'BLAKE@hotmail.com', null);
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, NULL, 10,'CLARK@acme.com', '{"skills":["C","C++","SQL"]}')
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7788, 'SCOTT', 'ANALYST', 7566, '1982-12-09', 3000, NULL, 20,'SCOTT@acme.com', '{"cat":"tiger"}');
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES  (7839, 'KING', 'PRESIDENT', NULL, '1981-11-17', 5000, NULL, 10,'KING@aol.com', null); 
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30,'TURNER@acme.com', null);
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7876, 'ADAMS', 'CLERK', 7788, '1983-01-12', 1100, NULL, 20,'ADAMS@acme.org', null); 
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, NULL, 30,'JAMES@acme.org', null);
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7902, 'FORD', 'DEVELOPER', 7566, '1981-12-03', 3000, NULL, 20,'FORD@acme.com', '{"skills":["YSQL","YCQL","SQL","CQL"]}'); 
INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, NULL, 10,'MILLER@acme.com', null);



--

INSERT INTO emp (empno, ename, job, mgr, hiredate, sal, comm, deptno, email, other_info) VALUES (7369, 'SMITH', 'CLERK', 7902, '1980-12-17', 800, NULL, 20,'SMITH@acme.com', '{"skills":["accounting"]}'), (7499, 'ALLEN', 'SALESMAN', 7698, '1981-02-20', 1600, 300, 30,'ALLEN@acme.com', null), (7521, 'WARD', 'SALESMAN', 7698, '1981-02-22', 1250, 500, 30,'WARD@compuserve.com', null), (7566, 'JONES', 'MANAGER', 7839, '1981-04-02', 2975, NULL, 20,'JONES@gmail.com', null), (7654, 'MARTIN', 'SALESMAN', 7698, '1981-09-28', 1250, 1400, 30,'MARTIN@acme.com', null), (7698, 'BLAKE', 'MANAGER', 7839, '1981-05-01', 2850, NULL, 30,'BLAKE@hotmail.com', null), (7782, 'CLARK', 'MANAGER', 7839, '1981-06-09', 2450, NULL, 10,'CLARK@acme.com', '{"skills":["C","C++","SQL"]}'), (7788, 'SCOTT', 'ANALYST', 7566, '1982-12-09', 3000, NULL, 20,'SCOTT@acme.com', '{"cat":"tiger"}'), (7839, 'KING', 'PRESIDENT', NULL, '1981-11-17', 5000, NULL, 10,'KING@aol.com', null), (7844, 'TURNER', 'SALESMAN', 7698, '1981-09-08', 1500, 0, 30,'TURNER@acme.com', null), (7876, 'ADAMS', 'CLERK', 7788, '1983-01-12', 1100, NULL, 20,'ADAMS@acme.org', null), (7900, 'JAMES', 'CLERK', 7698, '1981-12-03', 950, NULL, 30,'JAMES@acme.org', null), (7902, 'FORD', 'ANALYST', 7566, '1981-12-03', 3000, NULL, 20,'FORD@acme.com', '{"skills":["YSQL","YCQL","SQL","CQL"]}'), (7934, 'MILLER', 'CLERK', 7782, '1982-01-23', 1300, NULL, 10,'MILLER@acme.com', null);



1. Basics
Learn to use YSQL to update, access, and analyze the data stored in a database

Scenario 1. SQL Updates
Update salary for all employees who are not managers

Description
A SQL update can compute the new value and return it without the need to query again. The following adds 100 to the salaries of all employees who are not managers and show the new value

SQL Statement
Copy
Run
update emp set sal=sal+100
where job != 'MANAGER'
returning ename,sal as new_salary;



Scenario 2. Join
List all employees earning more than their managers using a self-join query.

Description
A self join is a regular join, but the table is joined with itself. The following SQL statement matches employees with their manager and filters those that are earning more than their manager.

SQL Statement
Copy
Run
SELECT 
  employee.ename,
  employee.sal,
  manager.ename as "manager ename",
  manager.sal as "manager sal"
FROM
  emp employee
JOIN emp manager ON
  employee.mgr = manager.empno
WHERE
  manager.sal<employee.sal
ORDER BY employee.sal;


Scenario 3. Prepared Statements
Get salary for an employee with a prepared statement


Description
Get salary for an employee with a prepared statement that declares a fixed query with typed parameters to prevent SQL injection

SQL Statement
Step 1: Prepare a statement employee_salary with a parameterized query

A prepared statement declares parameterized SQL. The following will display the name and salary for a provided employee number (as integer)

Copy
Run
prepare employee_salary(int) as select ename,sal from emp where empno=$1;


Step 2: Use the EXECUTE statement to execute a previously prepared statement. The following SQL executes the prepared statement with an employee ID 7900

Once prepared, the statement can be called by providing only the parameter value. This displays the name and salary of employee number 7900

Copy
Run
execute employee_salary(7900);
Step 3: Execute the same prepared statement another employee ID 7902

Without writing the SQL again, this displays the name and salary of employee number 7902

Copy
Run
execute employee_salary(7902);
Step 4: Use the DEALLOCATE statement to deallocate a previously prepared SQL statement

A prepared statement stays in the session and can be deallocated when not used anymore. The following frees the memory used by this statement

Copy
Run
deallocate employee_salary;




----- 

Scenario 4. Indexes
Create and analyze index on the fly

Description
Create a new table and a specific index to avoid table scan and sorts

SQL Statement
Step 1: Create a new demo table with randomly generated rows

GENERATE_SERIES function can generate rows. The following uses it to create a table with 42 rows and a random value from 1 to 10

Copy
Run
create table demo as select generate_series(1,42) num, round(10*random()) val;
Step 2: Create the index “demo_val” on demo table

With the goal to query, for a value, with numbers ordered, in the most efficient way, the following creates an index on “val” (hashed for distribution) and “num” in ascending order

Copy
Run
create index demo_val on demo(val hash,num asc);
Step 3: Gather optimizer statistics on table demo

The query planner chooses the best access path when provided with statistics about the data stored in the table. The following gathers those statistics

Copy
Run
analyze demo;
Step 4: Query the Top-3 numbers for a specific value

The following displays the Top-3 numbers for the value 5

Copy
Run
select * from demo where val=5 order by num asc fetch first 3 rows only;
Step 5: Verify that index is leading to faster query execution using explain analyze

When defining an index for a specific access pattern, it is good that the developer verifies that the index is used. The following shows that an “Index Only Scan” was used, without the need for an additional “Sort” operation

Copy
Run
explain analyze select * from demo where val=5 order by num fetch first 3 rows only;
Step 6: Clean up the table for this exercise.

To leave the database in the same state as before this exercise, the following removes the demo table created before

Copy
Run
drop table if exists demo;








Scenario 5. Recursive Queries
View
List the hierarchy of employees under a manager using WITH RECURSIVE


Description
The following example uses the WITH RECURSIVE clause to follow the hierarchy under JONES management, down to the last level. The first subquery in the recursive clause starts at JONES. The second lists the employees having him as a manager. They are declared with a UNION ALL and they will be executed recursively to get the other levels.

SQL Statement
Copy
Run
with recursive emp_manager as (
      select empno, ename, ename as path
      from emp where ename='JONES'
   union all
      select emp.empno, emp.ename,
             emp_manager.path || ' manages ' || emp.ename
      from emp join emp_manager on emp.mgr = emp_manager.empno
)
select * from emp_manager;





2. Built-in Functions
Learn powerful functions for performing complex database operations with ease

Scenario 1. Window Functions
Compare employees hiring time interval by department using LAG function
Description
LAG is a window function that provides access to the row before the current one. The following SQL statement uses WINDOW to define groups of employees by department, in order of their hiring date. LAG is used to access the previous row in this group, to compare the hiring date interval between two employees. FORMAT builds a text from column values, and COALESCE handles the first hire for which there is no previous row in the group. Without those window functions, this query would have required reading the same table two times.

SQL Statement
Copy
Run
select
dname,ename,job,
coalesce (
  'hired '||to_char(hiredate -
    lag(hiredate) over (per_dept_hiredate),'999')||' days after '||
    lag(ename) over (per_dept_hiredate),
    format('(1st hire in %L)',dname)
) as "last hire in dept"
from emp join dept using(deptno)
window per_dept_hiredate
  as (partition by dname order by hiredate)
order by dname,hiredate;




Scenario 2. Regexp Matching
List all employees with @gmail or .org in their email addresses
Description
REGEXP performs a pattern match of a string expression. The following lists employees with an e-mail ending in ‘.org’ or a domain starting with ‘gmail.’

SQL Statement
Copy
Run
select * from emp
where email ~ any ( ARRAY[ '@.*\.org$' , '@gmail\.' ] );



Scenario 3. Arithmetic Date Intervals
Description
The interval data type allows you to store and manipulate a period of time in years, months, days... The following example compares overlapping evaluation periods. A WITH clause defines the evaluation period length depending on the job

SQL Statement
Copy
Run
with emp_evaluation_period as (
 select ename,deptno,hiredate,
 hiredate + case when job in ('MANAGER','PRESIDENT')
 then interval '3 month' else interval '4 weeks'
 end evaluation_end from emp)
select * from emp_evaluation_period e1
 join emp_evaluation_period e2
 on (e1.ename>e2.ename) and (e1.deptno=e2.deptno)
where (e1.hiredate,e1.evaluation_end)
 overlaps (e2.hiredate,e2.evaluation_end);




Find employees with overlapping evaluation periods
Scenario 4. CROSSTABVIEW
Description
CROSSTABVIEW is a client command to display rows as columns. The following sums the salaries across jobs and departments and displays them as a cross-table

SQL Statement
Copy
Run
select job, dname, sum(sal)
from emp join dept using(deptno)
group by dname, job
\crosstabview



Display total salary per job and department as a cross-table
Scenario 5. NTILE Function
View
Split e-mails in 3 groups and format them


Description
In order to same e-mails to all employees in different batches, we will split them into 3 groups using the NTILE function, and format them with the FORMAT function and aggregate them in a comma-separated list with the STRING_AGG function

SQL Statement
Copy
Run
with groups as (
 select ntile(3) over (order by empno) group_num
 ,* 
 from emp
)
select string_agg(format('<%s> %s',ename,email),', ') 
from groups group by group_num;






Advanced Features
Expand your YSQL skills by completing the following 5 scenarios

Scenario 1. GIN Index on Document
List employees that know SQL
Description
The skills are stored in the semi-structured JSON document. We can query them with @>, ?, ?& and ?| operators. And, for best performance, index them.

SQL Statement
Step 1: Create GIN index on JSON document

GIN indexes can provide fast access to elements inside a JSON document. The following creates an index on the ‘skills’ attributes within ‘other_info’ JSON column

Copy
Run
create index emp_skills on emp using gin((other_info->'skills'));
Step 2: Query the JSON attribute list

SQL queries can navigate into the JSON document with -> and check if an array contains a value with @>. The following searches the employees with the “SQL” skill



Copy
Run
select * from emp where other_info->'skills' @> '"SQL"' ;
Step 3: Use Explain plan to verify that index is used

Thanks to the GIN index, this search doesn’t need to read all documents. The following shows the execution plan being an indexed access path

Copy
Run
explain select * from emp where other_info->'skills' @> '"SQL"' ;

---
Scenario 2. Text Search
Build a search index on department descriptions

Description
SQL queries can search in the text for some words using the to_tsvector() function to extract a list of words that can be compared. We will find all department descriptions with the words 'responsible' and 'services' in it

SQL Statement
Step 1: Create text search index on the description column

GIN indexes can provide fast access to words inside a text. The following creates an index for the simple-grammar vector of words extracted from the department description

Copy
Run
create index dept_description_text_search on dept using gin (( to_tsvector('simple',description) ));
Step 2: Query on description for matching words

The following compares the simple-grammar vector of words extracted from the department description with a word search pattern to find the departments which contain ‘responsible’ and ‘service’ in their description

Copy
Run
select * from dept where to_tsvector('simple',description) @@ to_tsquery('simple','responsible & services');
Step 3: Explain plan to verify that index is used

Thanks to the GIN index, this search doesn’t need to read all rows and text. The following shows the execution plan being an indexed access path

Copy
Run
explain select * from dept where to_tsvector('simple',description) @@ to_tsquery('simple','responsible & services');


---

Scenario 3. Stored Procedures
Transfer commission from one employee to another


Description
A stored procedure can encapsulate a procedural logic into an atomic operation. We will create one in PL/pgSQL, named "commission_transfer", that transfers commission “amount” from “empno1” to “empno2”

SQL Statement
Step 1: Create the procedure for the commission transfer between employees

The procedure has two SQL operations: decrease from “empno1” and add to “empno2”. Plus error checking to raise a custom exception if “empno1” doesn’t have the amount to be transferred

Copy
Run
create or replace procedure commission_transfer(empno1 int, empno2 int, amount int) as $$
begin
update emp set comm=comm-commission_transfer.amount
  where empno=commission_transfer.empno1 and comm>commission_transfer.amount;
if not found then raise exception 'Cannot transfer % from %',amount,empno1; end if;
update emp set comm=comm+commission_transfer.amount
  where emp.empno=commission_transfer.empno2;
if not found then raise exception 'Cannot transfer from %',empno2; end if;
end;
$$ language plpgsql;

Step 2: Call the procedure with employee IDs and the amount to be transferred

Once defined, the stored procedure is called with values for all parameters. This transfers 100 from employee 7521 to 7654

Copy
Run
call commission_transfer(7521,7654,200);

Step 3: List all employees who have received commission

The following displays all employees having a commission, to verify that 100 have been transferred

Copy
Run
select * from emp where comm is not null;
Step 4: Call the procedure with employee IDs and amount that is not allowed to invoke error handling

The following attempts to transfer 1000000, more than what 7521 has. It raises the “Cannot transfer” error defined in the procedure and automatically reverts all intermediate changes to return to a consistent state

Copy
Run
call commission_transfer(7521,7654,1000000);




Scenario 4. Triggers
Record the last update time of each row automatically


Description
We will add a column to hold the last update time, and declare a trigger to update it automatically, on the departments table

SQL Statement
Step 1: Add a column to store the last update time

The structure of a SQL table can evolve. With the goal of recording the last update, the following adds a “last_update” column to the department table

Copy
Run
alter table dept add last_update timestamptz;
Step 2: Add a function “dept_last_update” to set the last update time. The following SQL query uses the inbuilt transaction_timestamp() function which returns the current date and time at the start of the current transaction

A stored function declares some procedural logic that returns a value. The following returns the “new” state for a trigger after setting the “last_update” to the current time

Copy
Run
create or replace function dept_last_update() returns trigger as $$
begin
  new.last_update:=transaction_timestamp();
  return new;
end;
$$ language plpgsql;

Step 3: Create a trigger “dept_last_update” to call the function “dept_last_update” on each table update

The previous function can be called automatically. The following trigger executes it on each row update for the departments table

Copy
Run
create trigger dept_last_update
before update on dept
for each row
execute procedure dept_last_update();

Step 4: Display the current state of the table

In order to verify the automatic logging of the last update time, the following displays the current state of departments before any update

Copy
Run
select deptno,dname,loc,last_update from dept;
Step 5: Update multiple rows in one transaction in the dept table

Multiple updates can be declared in a single atomic transaction with BEGIN TRANSACTION and COMMIT. The following updates the location of departments 30 and 40 with a 3 seconds interval in between

Copy
Run
begin transaction;
update dept set loc='SUNNYVALE' where deptno=30;
select pg_sleep(3);
update dept set loc='SUNNYVALE' where deptno=40;
commit;

Step 6: Display the new state of the table to see the last_update column being updated

The following shows that in addition of the change location, the last update timestamp has been automatically set. Even if the updates were done at 3 seconds interval, they show the same update time because all was run in an atomic transaction

Copy
Run
select deptno,dname,loc,last_update from dept;




Scenario 5. Materialized Views
View
Pre-compute analytics for reporting, with a materialized view

Description
In order to get fast on-demand reports, we create a materialized view to store pre-joined and pre-aggregated data. This view will store the total salary per department, the number of employees, and the list of jobs in the department.

SQL Statement
Step 1: Create the materialized view

Copy
Run
create materialized view report_sal_per_dept as
select 
deptno,dname,
sum(sal) sal_per_dept,
count(*) num_of_employees,
string_agg(distinct job,', ') distinct_jobs
from dept join emp using(deptno)
group by deptno,dname
order by deptno;

Step 2: Indexes can be created on it. This one allows fast queries on a range of total salary

Copy
Run
create index report_sal_per_dept_sal on report_sal_per_dept(sal_per_dept desc);

Step 3: A refresh can be scheduled on a daily basis to re-compute it in the background with a simple command.

Copy
Run
refresh materialized view report_sal_per_dept;
Step 4: Querying the materialized view will show the data consistent as of the last refresh. This one lists the departments with a total salary lower than 10000

Copy
Run
select *
from report_sal_per_dept
where sal_per_dept<=10000
order by sal_per_dept;
Step 5: The execution plan shows that no additional join or group by are needed when querying this materialized view:

Copy
Run
explain analyze
select *
from report_sal_per_dept
where sal_per_dept<=10000
order by sal_per_dept;



yugabyte=> select version();
                                                                                         version                                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 PostgreSQL 11.2-YB-2.13.0.0-b0 on x86_64-pc-linux-gnu, compiled by clang version 12.0.1 (https://github.com/yugabyte/llvm-project.git bdb147e675d8c87cee72cc1f87c4b82855977d94), 64-bit



     